{"version":3,"file":"jsforce-api-bulk.min.js","sources":["jsforce-api-bulk.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","jsforce","modules","api","Bulk","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"process","inherits","stream","Duplex","events","_","RecordStream","Promise","HttpApi","Job","bulk","type","operation","options","jobId","_bulk","id","state","_batches","EventEmitter","prototype","info","callback","_jobInfo","check","thenCall","open","_logger","toLowerCase","body","extIdField","join","_request","method","path","headers","Content-Type","responseType","then","res","emit","jobInfo","err","createBatch","batch","Batch","on","batchId","logger","_waitAssign","debug","object","list","batchInfoList","batchInfo","isArray","close","_changeState","abort","job","super_","objectMode","_deferred","defer","_setupDataStreams","Writable","converterOptions","nullValue","_uploadStream","Serializable","_uploadDataStream","_downloadStream","Parsable","_downloadDataStream","end","once","pipe","_createRequestStream","dataStream","_dataStream","_write","data","enc","cb","write","read","push","_read","size","chunk","record","clone","Id","attributes","run","exec","execute","input","_result","rdeferred","promise","resolve","reject","isObject","isFunction","forEach","isString","onResolved","onReject","onProgress","nextTick","poll","interval","timeout","startTime","Date","getTime","now","name","parseInt","numberRecordsProcessed","retrieve","stateMessage","setTimeout","results","_conn","result","map","ret","success","Success","errors","resultId","resultStream","resultDataStream","BulkApi","apply","arguments","beforeSend","request","accessToken","isSessionExpired","response","statusCode","test","hasErrorInResponseBody","error","parseError","errorCode","exceptionCode","message","exceptionMessage","conn","pollInterval","pollTimeout","baseUrl","instanceUrl","version","url","load","createJob","cleanup","cleanupOnError","query","soql","m","replace","match","recordStream","_process",2,"drainQueue","draining","currentQueue","len","queue","noop","fun","title","browser","env","argv","versions","addListener","off","removeListener","removeAllListeners","binding","cwd","chdir","dir","umask"],"mappings":"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","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g=(g.jsforce||(g.jsforce = {}));g=(g.modules||(g.modules = {}));g=(g.api||(g.api = {}));g.Bulk = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process){\n/*global process*/\r\n/**\r\n * @file Manages Salesforce Bulk API related operations\r\n * @author Shinichi Tomita <shinichi.tomita@gmail.com>\r\n */\r\n\r\n'use strict';\r\n\r\nvar inherits     = jsforce.require('inherits'),\r\n    stream       = jsforce.require('readable-stream'),\r\n    Duplex       = stream.Duplex,\r\n    events       = jsforce.require('events'),\r\n    _            = jsforce.require('underscore'),\r\n    RecordStream = jsforce.require('./record-stream'),\r\n    CSV          = jsforce.require('./csv'),\r\n    Promise      = jsforce.require('./promise'),\r\n    HttpApi      = jsforce.require('./http-api');\r\n\r\n/*--------------------------------------------*/\r\n\r\n/**\r\n * Class for Bulk API Job\r\n *\r\n * @protected\r\n * @class Bulk~Job\r\n * @extends events.EventEmitter\r\n * \r\n * @param {Bulk} bulk - Bulk API object\r\n * @param {String} [type] - SObject type\r\n * @param {String} [operation] - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\r\n * @param {Object} [options] - Options for bulk loading operation\r\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\r\n * @param {String} [jobId] - Job ID (if already available)\r\n */\r\nvar Job = function(bulk, type, operation, options, jobId) {\r\n  this._bulk = bulk;\r\n  this.type = type;\r\n  this.operation = operation;\r\n  this.options = options || {};\r\n  this.id = jobId;\r\n  this.state = this.id ? 'Open' : 'Unknown';\r\n  this._batches = {};\r\n};\r\n\r\ninherits(Job, events.EventEmitter);\r\n\r\n/**\r\n * @typedef {Object} Bulk~JobInfo\r\n * @prop {String} id - Job ID\r\n * @prop {String} object - Object type name\r\n * @prop {String} operation - Operation type of the job\r\n * @prop {String} state - Job status\r\n */\r\n\r\n/**\r\n * Return latest jobInfo from cache\r\n *\r\n * @method Bulk~Job#open\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype.info = function(callback) {\r\n  var self = this;\r\n  // if cache is not available, check the latest\r\n  if (!this._jobInfo) {\r\n    this._jobInfo = this.check();\r\n  }\r\n  return this._jobInfo.thenCall(callback);\r\n};\r\n\r\n/**\r\n * Open new job and get jobinfo\r\n *\r\n * @method Bulk~Job#open\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype.open = function(callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var logger = bulk._logger;\r\n\r\n  // if not requested opening job\r\n  if (!this._jobInfo) {\r\n    var operation = this.operation.toLowerCase();\r\n    if (operation === 'harddelete') { operation = 'hardDelete'; }\r\n    var body = [\r\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\r\n      '<jobInfo  xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\r\n        '<operation>' + operation + '</operation>',\r\n        '<object>' + this.type + '</object>',\r\n        (this.options.extIdField ?\r\n         '<externalIdFieldName>'+this.options.extIdField+'</externalIdFieldName>' :\r\n         ''),\r\n        '<contentType>CSV</contentType>',\r\n      '</jobInfo>'\r\n    ].join('');\r\n\r\n    this._jobInfo = bulk._request({\r\n      method : 'POST',\r\n      path : \"/job\",\r\n      body : body,\r\n      headers : {\r\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\r\n      },\r\n      responseType: \"application/xml\"\r\n    }).then(function(res) {\r\n      self.emit(\"open\", res.jobInfo);\r\n      self.id = res.jobInfo.id;\r\n      self.state = res.jobInfo.state;\r\n      return res.jobInfo;\r\n    }, function(err) {\r\n      self.emit(\"error\", err);\r\n      throw err;\r\n    });\r\n  }\r\n  return this._jobInfo.thenCall(callback);\r\n};\r\n\r\n/**\r\n * Create a new batch instance in the job\r\n *\r\n * @method Bulk~Job#createBatch\r\n * @returns {Bulk~Batch}\r\n */\r\nJob.prototype.createBatch = function() {\r\n  var batch = new Batch(this);\r\n  var self = this;\r\n  batch.on('queue', function() {\r\n    self._batches[batch.id] = batch;\r\n  });\r\n  return batch;\r\n};\r\n\r\n/**\r\n * Get a batch instance specified by given batch ID\r\n *\r\n * @method Bulk~Job#batch\r\n * @param {String} batchId - Batch ID\r\n * @returns {Bulk~Batch}\r\n */\r\nJob.prototype.batch = function(batchId) {\r\n  var batch = this._batches[batchId];\r\n  if (!batch) {\r\n    batch = new Batch(this, batchId);\r\n    this._batches[batchId] = batch;\r\n  }\r\n  return batch;\r\n};\r\n\r\n/**\r\n * Check the latest job status from server\r\n *\r\n * @method Bulk~Job#check\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype.check = function(callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var logger = bulk._logger;\r\n\r\n  this._jobInfo = this._waitAssign().then(function() {\r\n    return bulk._request({\r\n      method : 'GET',\r\n      path : \"/job/\" + self.id,\r\n      responseType: \"application/xml\"\r\n    });\r\n  }).then(function(res) {\r\n    logger.debug(res.jobInfo);\r\n    self.id = res.jobInfo.id;\r\n    self.type = res.jobInfo.object;\r\n    self.operation = res.jobInfo.operation;\r\n    self.state = res.jobInfo.state;\r\n    return res.jobInfo;\r\n  });\r\n  return this._jobInfo.thenCall(callback);\r\n};\r\n\r\n/**\r\n * Wait till the job is assigned to server\r\n *\r\n * @method Bulk~Job#info\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype._waitAssign = function(callback) {\r\n  return (this.id ? new Promise({ id: this.id }) : this.open()).thenCall(callback);\r\n};\r\n\r\n\r\n/**\r\n * List all registered batch info in job\r\n *\r\n * @method Bulk~Job#list\r\n * @param {Callback.<Array.<Bulk~BatchInfo>>} [callback] - Callback function\r\n * @returns {Promise.<Array.<Bulk~BatchInfo>>}\r\n */\r\nJob.prototype.list = function(callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var logger = bulk._logger;\r\n\r\n  return this._waitAssign().then(function() {\r\n    return bulk._request({\r\n      method : 'GET',\r\n      path : \"/job/\" + self.id + \"/batch\",\r\n      responseType: \"application/xml\"\r\n    });\r\n  }).then(function(res) {\r\n    logger.debug(res.batchInfoList.batchInfo);\r\n    var batchInfoList = res.batchInfoList;\r\n    batchInfoList = _.isArray(batchInfoList.batchInfo) ? batchInfoList.batchInfo : [ batchInfoList.batchInfo ];\r\n    return batchInfoList;\r\n  }).thenCall(callback);\r\n\r\n};\r\n\r\n/**\r\n * Close opened job\r\n *\r\n * @method Bulk~Job#close\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype.close = function() {\r\n  var self = this;\r\n  return this._changeState(\"Closed\").then(function(jobInfo) {\r\n    self.id = null;\r\n    self.emit(\"close\", jobInfo);\r\n    return jobInfo;\r\n  }, function(err) {\r\n    self.emit(\"error\", err);\r\n    throw err;\r\n  });\r\n};\r\n\r\n/**\r\n * Set the status to abort\r\n *\r\n * @method Bulk~Job#abort\r\n * @param {Callback.<Bulk~JobInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~JobInfo>}\r\n */\r\nJob.prototype.abort = function() {\r\n  var self = this;\r\n  return this._changeState(\"Aborted\").then(function(jobInfo) {\r\n    self.id = null;\r\n    self.emit(\"abort\", jobInfo);\r\n    return jobInfo;\r\n  }, function(err) {\r\n    self.emit(\"error\", err);\r\n    throw err;\r\n  });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nJob.prototype._changeState = function(state, callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var logger = bulk._logger;\r\n\r\n  this._jobInfo = this._waitAssign().then(function() {\r\n    var body = [\r\n      '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\r\n      '<jobInfo xmlns=\"http://www.force.com/2009/06/asyncapi/dataload\">',\r\n        '<state>' + state + '</state>',\r\n      '</jobInfo>'\r\n    ].join('');\r\n    return bulk._request({\r\n      method : 'POST',\r\n      path : \"/job/\" + self.id,\r\n      body : body,\r\n      headers : {\r\n        \"Content-Type\" : \"application/xml; charset=utf-8\"\r\n      },\r\n      responseType: \"application/xml\"\r\n    });\r\n  }).then(function(res) {\r\n    logger.debug(res.jobInfo);\r\n    self.state = res.jobInfo.state;\r\n    return res.jobInfo;\r\n  });\r\n  return this._jobInfo.thenCall(callback);\r\n\r\n};\r\n\r\n\r\n/*--------------------------------------------*/\r\n\r\n/**\r\n * Batch (extends RecordStream)\r\n *\r\n * @protected\r\n * @class Bulk~Batch\r\n * @extends {stream.Writable}\r\n * @implements {Promise.<Array.<RecordResult>>}\r\n * @param {Bulk~Job} job - Bulk job object\r\n * @param {String} [batchId] - Batch ID (if already available)\r\n */\r\nvar Batch = function(job, batchId) {\r\n  Batch.super_.call(this, { objectMode: true });\r\n  this.job = job;\r\n  this.id = batchId;\r\n  this._bulk = job._bulk;\r\n  this._deferred = Promise.defer();\r\n  this._setupDataStreams();\r\n};\r\n\r\ninherits(Batch, stream.Writable);\r\n\r\n\r\n/**\r\n * @private\r\n */\r\nBatch.prototype._setupDataStreams = function() {\r\n  var batch = this;\r\n  var converterOptions = { nullValue : '#N/A' };\r\n  this._uploadStream = new RecordStream.Serializable();\r\n  this._uploadDataStream = this._uploadStream.stream('csv', converterOptions);\r\n  this._downloadStream = new RecordStream.Parsable();\r\n  this._downloadDataStream = this._downloadStream.stream('csv', converterOptions);\r\n\r\n  this.on('finish', function() {\r\n    batch._uploadStream.end();\r\n  });\r\n  this._uploadDataStream.once('readable', function() {\r\n    batch.job.open().then(function() {\r\n      // pipe upload data to batch API request stream\r\n      batch._uploadDataStream.pipe(batch._createRequestStream());\r\n    });\r\n  });\r\n\r\n  // duplex data stream, opened access to API programmers by Batch#stream()\r\n  var dataStream = this._dataStream = new Duplex();\r\n  dataStream._write = function(data, enc, cb) {\r\n    batch._uploadDataStream.write(data, enc, cb);\r\n  };\r\n  dataStream.on('finish', function() {\r\n    batch._uploadDataStream.end();\r\n  });\r\n\r\n  this._downloadDataStream.on('readable', function() {\r\n    dataStream.read(0);\r\n  });\r\n  this._downloadDataStream.on('end', function() {\r\n    dataStream.push(null);\r\n  });\r\n  dataStream._read = function(size) {\r\n    var chunk;\r\n    while ((chunk = batch._downloadDataStream.read()) !== null) {\r\n      dataStream.push(chunk);\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Connect batch API and create stream instance of request/response\r\n *\r\n * @private\r\n * @returns {stream.Duplex}\r\n */\r\nBatch.prototype._createRequestStream = function() {\r\n  var batch = this;\r\n  var bulk = batch._bulk;\r\n  var logger = bulk._logger;\r\n\r\n  return bulk._request({\r\n    method : 'POST',\r\n    path : \"/job/\" + batch.job.id + \"/batch\",\r\n    headers: {\r\n      \"Content-Type\": \"text/csv\"\r\n    },\r\n    responseType: \"application/xml\"\r\n  }, function(err, res) {\r\n    if (err) {\r\n      batch.emit('error', err);\r\n    } else {\r\n      logger.debug(res.batchInfo);\r\n      batch.id = res.batchInfo.id;\r\n      batch.emit('queue', res.batchInfo);\r\n    }\r\n  }).stream();\r\n};\r\n\r\n/**\r\n * Implementation of Writable\r\n *\r\n * @override\r\n * @private\r\n */\r\nBatch.prototype._write = function(record, enc, cb) {\r\n  record = _.clone(record);\r\n  if (this.job.operation === \"insert\") {\r\n    delete record.Id;\r\n  } else if (this.job.operation === \"delete\") {\r\n    record = { Id: record.Id };\r\n  }\r\n  delete record.type;\r\n  delete record.attributes;\r\n  this._uploadStream.write(record, enc, cb);\r\n};\r\n\r\n/**\r\n * Returns duplex stream which accepts CSV data input and batch result output\r\n *\r\n * @returns {stream.Duplex}\r\n */\r\nBatch.prototype.stream = function() {\r\n  return this._dataStream;\r\n};\r\n\r\n/**\r\n * Execute batch operation\r\n *\r\n * @method Bulk~Batch#execute\r\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for batch operation. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\r\n * @param {Callback.<Array.<RecordResult>|Array.<BatchResultInfo>>} [callback] - Callback function\r\n * @returns {Bulk~Batch}\r\n */\r\nBatch.prototype.run =\r\nBatch.prototype.exec =\r\nBatch.prototype.execute = function(input, callback) {\r\n  var self = this;\r\n\r\n  if (typeof input === 'function') { // if input argument is omitted\r\n    callback = input;\r\n    input = null;\r\n  }\r\n\r\n  // if batch is already executed\r\n  if (this._result) {\r\n    throw new Error(\"Batch already executed.\");\r\n  }\r\n\r\n  var rdeferred = Promise.defer();\r\n  this._result = rdeferred.promise;\r\n  this._result.then(function(res) {\r\n    self._deferred.resolve(res);\r\n  }, function(err) {\r\n    self._deferred.reject(err);\r\n  });\r\n  this.once('response', function(res) {\r\n    rdeferred.resolve(res);\r\n  });\r\n  this.once('error', function(err) {\r\n    rdeferred.reject(err);\r\n  });\r\n\r\n  if (_.isObject(input) && _.isFunction(input.pipe)) { // if input has stream.Readable interface\r\n    input.pipe(this._dataStream);\r\n  } else {\r\n    var data;\r\n    if (_.isArray(input)) {\r\n      _.forEach(input, function(record) { self.write(record); });\r\n      self.end();\r\n    } else if (_.isString(input)){\r\n      data = input;\r\n      this._dataStream.write(data, 'utf8');\r\n      this._dataStream.end();\r\n    }\r\n  }\r\n\r\n  // return Batch instance for chaining\r\n  return this.thenCall(callback);\r\n};\r\n\r\n/**\r\n * Promise/A+ interface\r\n * http://promises-aplus.github.io/promises-spec/\r\n *\r\n * Delegate to deferred promise, return promise instance for batch result\r\n *\r\n * @method Bulk~Batch#then\r\n */\r\nBatch.prototype.then = function(onResolved, onReject, onProgress) {\r\n  return this._deferred.promise.then(onResolved, onReject, onProgress);\r\n};\r\n\r\n/**\r\n * Promise/A+ extension\r\n * Call \"then\" using given node-style callback function\r\n *\r\n * @method Bulk~Batch#thenCall\r\n */\r\nBatch.prototype.thenCall = function(callback) {\r\n  if (_.isFunction(callback)) {\r\n    this.then(function(res) {\r\n      process.nextTick(function() {\r\n        callback(null, res);\r\n      });\r\n    }, function(err) {\r\n      process.nextTick(function() {\r\n        callback(err);\r\n      });\r\n    });\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * @typedef {Object} Bulk~BatchInfo\r\n * @prop {String} id - Batch ID\r\n * @prop {String} jobId - Job ID\r\n * @prop {String} state - Batch state\r\n * @prop {String} stateMessage - Batch state message\r\n */\r\n\r\n/**\r\n * Check the latest batch status in server\r\n *\r\n * @method Bulk~Batch#check\r\n * @param {Callback.<Bulk~BatchInfo>} [callback] - Callback function\r\n * @returns {Promise.<Bulk~BatchInfo>}\r\n */\r\nBatch.prototype.check = function(callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var logger = bulk._logger;\r\n  var jobId = this.job.id;\r\n  var batchId = this.id;\r\n\r\n  if (!jobId || !batchId) {\r\n    throw new Error(\"Batch not started.\");\r\n  }\r\n  return bulk._request({\r\n    method : 'GET',\r\n    path : \"/job/\" + jobId + \"/batch/\" + batchId,\r\n    responseType: \"application/xml\"\r\n  }).then(function(res) {\r\n    logger.debug(res.batchInfo);\r\n    return res.batchInfo;\r\n  }).thenCall(callback);\r\n};\r\n\r\n\r\n/**\r\n * Polling the batch result and retrieve\r\n *\r\n * @method Bulk~Batch#poll\r\n * @param {Number} interval - Polling interval in milliseconds\r\n * @param {Number} timeout - Polling timeout in milliseconds\r\n */\r\nBatch.prototype.poll = function(interval, timeout) {\r\n  var self = this;\r\n  var jobId = this.job.id;\r\n  var batchId = this.id;\r\n\r\n  if (!jobId || !batchId) {\r\n    throw new Error(\"Batch not started.\");\r\n  }\r\n  var startTime = new Date().getTime();\r\n  var poll = function() {\r\n    var now = new Date().getTime();\r\n    if (startTime + timeout < now) {\r\n      var err = new Error(\"Polling time out. Job Id = \" + jobId + \" , batch Id = \" + batchId);\r\n      err.name = 'PollingTimeout';\r\n      self.emit('error', err);\r\n      return;\r\n    }\r\n    self.check(function(err, res) {\r\n      if (err) {\r\n        self.emit('error', err);\r\n      } else {\r\n        if (res.state === \"Failed\") {\r\n          if (parseInt(res.numberRecordsProcessed, 10) > 0) {\r\n            self.retrieve();\r\n          } else {\r\n            self.emit('error', new Error(res.stateMessage));\r\n          }\r\n        } else if (res.state === \"Completed\") {\r\n          self.retrieve();\r\n        } else {\r\n          self.emit('progress', res);\r\n          setTimeout(poll, interval);\r\n        }\r\n      }\r\n    });\r\n  };\r\n  setTimeout(poll, interval);\r\n};\r\n\r\n/**\r\n * @typedef {Object} Bulk~BatchResultInfo\r\n * @prop {String} id - Batch result ID\r\n * @prop {String} batchId - Batch ID which includes this batch result.\r\n * @prop {String} jobId - Job ID which includes this batch result.\r\n */\r\n\r\n/**\r\n * Retrieve batch result\r\n *\r\n * @method Bulk~Batch#retrieve\r\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\r\n * @returns {Promise.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>}\r\n */\r\nBatch.prototype.retrieve = function(callback) {\r\n  var self = this;\r\n  var bulk = this._bulk;\r\n  var jobId = this.job.id;\r\n  var job = this.job;\r\n  var batchId = this.id;\r\n\r\n  if (!jobId || !batchId) {\r\n    throw new Error(\"Batch not started.\");\r\n  }\r\n\r\n  return job.info().then(function(jobInfo) {\r\n    return bulk._request({\r\n      method : 'GET',\r\n      path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result\"\r\n    });\r\n  }).then(function(res) {\r\n    var results;\r\n    if (job.operation === 'query') {\r\n      var conn = bulk._conn;\r\n      var resultIds = res['result-list'].result;\r\n      results = res['result-list'].result;\r\n      results = _.map(_.isArray(results) ? results : [ results ], function(id) {\r\n        return {\r\n          id: id,\r\n          batchId: batchId,\r\n          jobId: jobId\r\n        };\r\n      });\r\n    } else {\r\n      results = _.map(res, function(ret) {\r\n        return {\r\n          id: ret.Id || null,\r\n          success: ret.Success === \"true\",\r\n          errors: ret.Error ? [ ret.Error ] : []\r\n        };\r\n      });\r\n    }\r\n    self.emit('response', results);\r\n    return results;\r\n  }, function(err) {\r\n    self.emit('error', err);\r\n    throw err;\r\n  }).thenCall(callback);\r\n};\r\n\r\n/**\r\n * Fetch query result as a record stream\r\n * @param {String} resultId - Result id\r\n * @returns {RecordStream} - Record stream, convertible to CSV data stream\r\n */\r\nBatch.prototype.result = function(resultId) {\r\n  var jobId = this.job.id;\r\n  var batchId = this.id;\r\n  if (!jobId || !batchId) {\r\n    throw new Error(\"Batch not started.\");\r\n  }\r\n  var resultStream = new RecordStream.Parsable();\r\n  var resultDataStream = resultStream.stream('csv');\r\n  var reqStream = this._bulk._request({\r\n    method : 'GET',\r\n    path : \"/job/\" + jobId + \"/batch/\" + batchId + \"/result/\" + resultId\r\n  }).stream().pipe(resultDataStream);\r\n  return resultStream;\r\n};\r\n\r\n/*--------------------------------------------*/\r\n/**\r\n * @private\r\n */\r\nvar BulkApi = function() {\r\n  BulkApi.super_.apply(this, arguments);\r\n};\r\n\r\ninherits(BulkApi, HttpApi);\r\n\r\nBulkApi.prototype.beforeSend = function(request) {\r\n  request.headers = request.headers || {};\r\n  request.headers[\"X-SFDC-SESSION\"] = this._conn.accessToken;\r\n};\r\n\r\nBulkApi.prototype.isSessionExpired = function(response) {\r\n  return response.statusCode === 400 &&\r\n    /<exceptionCode>InvalidSessionId<\\/exceptionCode>/.test(response.body);\r\n};\r\n\r\nBulkApi.prototype.hasErrorInResponseBody = function(body) {\r\n  return !!body.error;\r\n};\r\n\r\nBulkApi.prototype.parseError = function(body) {\r\n  return {\r\n    errorCode: body.error.exceptionCode,\r\n    message: body.error.exceptionMessage\r\n  };\r\n};\r\n\r\n/*--------------------------------------------*/\r\n\r\n/**\r\n * Class for Bulk API\r\n *\r\n * @class\r\n * @param {Connection} conn - Connection object\r\n */\r\nvar Bulk = function(conn) {\r\n  this._conn = conn;\r\n  this._logger = conn._logger;\r\n};\r\n\r\n/** \r\n * Polling interval in milliseconds \r\n * @type {Number}\r\n */\r\nBulk.prototype.pollInterval = 1000;\r\n\r\n/**\r\n * Polling timeout in milliseconds\r\n * @type {Number}\r\n */\r\nBulk.prototype.pollTimeout = 10000;\r\n\r\n/** @private **/\r\nBulk.prototype._request = function(request, callback) {\r\n  var conn = this._conn;\r\n  request = _.clone(request);\r\n  var baseUrl = [ conn.instanceUrl, \"services/async\", conn.version ].join('/');\r\n  request.url = baseUrl + request.path;\r\n  var options = { responseType: request.responseType };\r\n  delete request.path;\r\n  delete request.responseType;\r\n  return new BulkApi(this._conn, options).request(request).thenCall(callback);\r\n};\r\n\r\n/**\r\n * Create and start bulkload job and batch\r\n *\r\n * @param {String} type - SObject type\r\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', or 'hardDelete')\r\n * @param {Object} [options] - Options for bulk loading operation\r\n * @param {String} [options.extIdField] - External ID field name (used when upsert operation).\r\n * @param {Array.<Record>|stream.Stream|String} [input] - Input source for bulkload. Accepts array of records, CSV string, and CSV data input stream in insert/update/upsert/delete/hardDelete operation, SOQL string in query operation.\r\n * @param {Callback.<Array.<RecordResult>|Array.<Bulk~BatchResultInfo>>} [callback] - Callback function\r\n * @returns {Bulk~Batch}\r\n */\r\nBulk.prototype.load = function(type, operation, options, input, callback) {\r\n  var self = this;\r\n  if (!type || !operation) {\r\n    throw new Error(\"Insufficient arguments. At least, 'type' and 'operation' are required.\");\r\n  }\r\n  if (operation.toLowerCase() !== 'upsert') { // options is only for upsert operation\r\n    callback = input;\r\n    input = options;\r\n    options = null;\r\n  }\r\n  var job = this.createJob(type, operation, options);\r\n  job.once('error', function (error) {\r\n    if (batch) {\r\n      batch.emit('error', error); // pass job error to batch\r\n    }\r\n  });\r\n  var batch = job.createBatch();\r\n  var cleanup = function() {\r\n    batch = null;\r\n    job.close();\r\n  };\r\n  var cleanupOnError = function(err) {\r\n    if (err.name !== 'PollingTimeout') {\r\n      cleanup();\r\n    }\r\n  };\r\n  batch.on('response', cleanup);\r\n  batch.on('error', cleanupOnError);\r\n  batch.on('queue', function() { batch.poll(self.pollInterval, self.pollTimeout); });\r\n  return batch.execute(input, callback);\r\n};\r\n\r\n/**\r\n * Execute bulk query and get record stream\r\n *\r\n * @param {String} soql - SOQL to execute in bulk job\r\n * @returns {RecordStream.Parsable} - Record stream, convertible to CSV data stream\r\n */\r\nBulk.prototype.query = function(soql) {\r\n  var m = soql.replace(/\\([\\s\\S]+\\)/g, '').match(/FROM\\s+(\\w+)/i);\r\n  if (!m) {\r\n    throw new Error(\"No sobject type found in query, maybe caused by invalid SOQL.\");\r\n  }\r\n  var type = m[1];\r\n  var self = this;\r\n  var recordStream = new RecordStream.Parsable();\r\n  var dataStream = recordStream.stream('csv');\r\n  this.load(type, \"query\", soql).then(function(results) {\r\n    // Ideally, it should merge result files into one stream.\r\n    // Currently only first batch result is the target (mostly enough).\r\n    var r = results[0];\r\n    var result = self.job(r.jobId).batch(r.batchId).result(r.id);\r\n    result.stream().pipe(dataStream);\r\n  });\r\n  return recordStream;\r\n};\r\n\r\n\r\n/**\r\n * Create a new job instance\r\n *\r\n * @param {String} type - SObject type\r\n * @param {String} operation - Bulk load operation ('insert', 'update', 'upsert', 'delete', 'hardDelete', or 'query')\r\n * @param {Object} [options] - Options for bulk loading operation\r\n * @returns {Bulk~Job}\r\n */\r\nBulk.prototype.createJob = function(type, operation, options) {\r\n  return new Job(this, type, operation, options);\r\n};\r\n\r\n/**\r\n * Get a job instance specified by given job ID\r\n *\r\n * @param {String} jobId - Job ID\r\n * @returns {Bulk~Job}\r\n */\r\nBulk.prototype.job = function(jobId) {\r\n  return new Job(this, null, null, null, jobId);\r\n};\r\n\r\n\r\n/*--------------------------------------------*/\r\n\r\nmodule.exports = Bulk;\r\n\n}).call(this,require('_process'))\n},{\"_process\":2}],2:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}]},{},[1])(1)\n});"]}